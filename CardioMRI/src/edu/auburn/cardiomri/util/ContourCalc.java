package edu.auburn.cardiomri.util;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Vector;
import edu.auburn.cardiomri.datastructure.Point;
import edu.auburn.cardiomri.datastructure.ControlPoint;
import edu.auburn.cardiomri.datastructure.TensionPoint;
import toxi.geom.Spline2D;
import toxi.geom.Vec2D;
import edu.auburn.cardiomri.datastructure.Contour;

public final class ContourCalc {
    /**
     * Distance between each of the generated points
     */
    public static float SEPARATION_DISTANCE = 1.0f; // Distance between each of
                                                    // the generated points

    /**
     * Calculates the centroid by averaging the x,y coordinates in the list
     *
     * @param points List of points used to find the centroid
     * @return The centroid of the points
     */
    public static Point calcCentroid(List<ControlPoint> points) {
        if (points == null) {
            throw new NullPointerException("List cannot be null");
        }
        if (points.size() == 0) {
            throw new IllegalArgumentException(
                    "List must have at least 1 point");
        }

        double averageX = 0, averageY = 0;
        for (ControlPoint p : points) {
            averageX += p.getX();
            averageY += p.getY();
        }
        averageX /= points.size();
        averageY /= points.size();

        Point centroid = new Point(averageX, averageY);
        return centroid;
    }

    /**
     * Sort the points in clockwise order.
     *
     * @param points List of points to sort
     */
    public static void sortPoints(List<ControlPoint> points) {
        if (points == null) {
            throw new NullPointerException("List cannot be null");
        }
        if (points.size() == 0) {
            return;
        }

        Point centroid = ContourCalc.calcCentroid(points);

        Collections.sort(points, new Comparator<ControlPoint>() {

            /**
             * Returns negative integer if point p1 is comes before point p2 in
             * the contour?
             */
            @Override
            public int compare(ControlPoint p1, ControlPoint p2) {
                double thetaP1 = Math.atan2(p1.getY() - centroid.getY(),
                        p1.getX() - centroid.getX());
                double thetaP2 = Math.atan2(p2.getY() - centroid.getY(),
                        p2.getX() - centroid.getX());
                double delta = thetaP2 - thetaP1;
                return (int) Math.signum(delta);
            }
        });
    }
    
   public static List<Point> generate(List<ControlPoint> controlPoints, boolean isClosed) {
    	
        if (controlPoints == null) {
      	  throw new NullPointerException("List cannot be null");
        }
        if (controlPoints.size() < 2 ) {
      	  return new Vector<Point>(controlPoints);
        }
        
        //final points that will make the contour
        List<Point> generatedPoints = new Vector<Point>(); 
        
        //points generated by the genCurve() function to be inserted into generatedPoints
        List<Point> curvePoints = new Vector<Point>();
        
        //ContourCalc.sortPoints(controlPoints);
        
        for(int i = 0; i < controlPoints.size() - 1 ; i++) {
      	  //generate points for every segment of the curve
      	  curvePoints = genCurve(controlPoints.get(i), controlPoints.get(i + 1));
      	  
      	  //add the segment to the contour
      	  generatedPoints.addAll(curvePoints);
        }
        
        //only close the contour if boolean is selected
        if(isClosed) {
	        curvePoints = genCurve(controlPoints.get(controlPoints.size() - 1), controlPoints.get(0));
	        
	        generatedPoints.addAll(curvePoints);
        }
        return generatedPoints;
        
    }
    
    /**
     * Compute the change in arc length if the given point is added to the contour.
     * 
     * @param contour
     * @param newPoint
     * @return
     */
    public static float getDeltaArcLength(Contour contour, ControlPoint newPoint) {
        List<ControlPoint> originalList = contour.getControlPoints();
        List<ControlPoint> modifiedList = contour.getControlPoints();
        modifiedList.add(newPoint);

        Spline2D original = getSplineFromControlPoints(originalList,
                contour.isClosedCurve());
        original.getDecimatedVertices(SEPARATION_DISTANCE);
        Spline2D modified = getSplineFromControlPoints(modifiedList,
                contour.isClosedCurve());
        modified.getDecimatedVertices(SEPARATION_DISTANCE);

        return modified.getEstimatedArcLength()
                - original.getEstimatedArcLength();
    }

    private static Spline2D getSplineFromControlPoints(
            List<ControlPoint> controlPoints, boolean isClosed) {
        ContourCalc.sortPoints(controlPoints);

        List<ControlPoint> rawPoints = new Vector<ControlPoint>(controlPoints);
        if (isClosed) {
            rawPoints.add(rawPoints.get(0));
        }

        Vec2D[] points = new Vec2D[rawPoints.size()];
        ControlPoint point;
        for (int i = 0; i < rawPoints.size(); i++) {
            point = rawPoints.get(i);
            points[i] = new Vec2D((float) point.getX(),
                    (float) point.getY());
        }

        Spline2D spline = new Spline2D(points);
        return spline;
    }
  
    public static List<TensionPoint> getTensionPoint(ControlPoint a, Point centroid) {
    	List<TensionPoint> twoTensionPoints = new Vector<TensionPoint>();
    	
    	//calculate vector to the control point
    	Point vector = new Point(a.getX() - centroid.getX(), a.getY() - centroid.getY());
    	
    	//calculate perpendicular vector 1
    	Point tVector1 = new Point((-0.6) * vector.getY(), (0.6) * vector.getX());
    	//calculate perpendicular vector 1
    	Point tVector2 = new Point((0.6) * vector.getY(), (-0.6) * vector.getX());
    	
    	//calculate tension point 1
    	TensionPoint tPoint1 = new TensionPoint(a.getX() + tVector1.getX(), a.getY() + tVector1.getY(), a);
    	//calculate tension point 2
    	TensionPoint tPoint2 = new TensionPoint(a.getX() + tVector2.getX(), a.getY() + tVector2.getY(), a);
    	
    	//add the points to the list
    	twoTensionPoints.add(tPoint1);
    	twoTensionPoints.add(tPoint2);
    	return twoTensionPoints;
    }
    
    public static List<Point> genCurve(ControlPoint a, ControlPoint b) {
    	
    	List<Point> bezierPoints = new Vector<Point>();
    	
    	//calculates the distance vector to the first tension point 		   
 		double distanceAX = a.getTension2().getX() - a.getX();
 		double distanceAY = a.getTension2().getY() - a.getY();
 		
 		//calculates the distance vector to the second tension from the first tension point
 		double distanceBX = b.getTension1().getX() - a.getTension2().getX();
 		double distanceBY = b.getTension1().getY() - a.getTension2().getY();
 		
 		if(distanceBX == 0 || distanceBY == 0) {
 			distanceBX = 0.1;
 			distanceBY = 0.1;
 		}
 		
 		//calculates the distance vector to the second control point from the second tension
 		double distanceCX = b.getX() - b.getTension1().getX();
 		double distanceCY = b.getY() - b.getTension1().getY();
 		   
     	for(int j = 0; j < 101; j++) {
     	   
     		//calculates the point j% along the line from the first control point to the first tension point
     		double aX = a.getX() + (j * (distanceAX/100));
     		double aY = a.getY() + (j * (distanceAY/100));
     		   
     		//calculates the point j% along the line from the first tension point to the second tension point
     		double bX = a.getTension2().getX() + (j * (distanceBX/100));
     		double bY = a.getTension2().getY() + (j * (distanceBY/100));
     		
     		//calculates the point j% along the line from the second tension point to the second control point
     		double cX = b.getTension1().getX() + (j * (distanceCX/100));
     		double cY = b.getTension1().getY() + (j * (distanceCY/100));
     	  
     		//calculates the distance for the first inner line
     		double distancePX = bX - aX; 
     		double distancePY = bY - aY; 
     		
     		//calculates the distance for the second inner line
     		double distanceQX = cX - bX;
     		double distanceQY = cY - bY;
     	   
     		//calculates the point j% along the first inner line
     		double pX = aX + (j * (distancePX/100));
     		double pY = aY + (j * (distancePY/100));
     		
     		//calculates the point j% along the second inner line
     		double qX = bX + (j * (distanceQX/100));
     		double qY = bY + (j * (distanceQY/100));

     		//calculates the distance for the last inner line
     		double distanceFX = qX - pX;
     		double distanceFY = qY - pY;
     		
     		//calculates the final point j% on the inner line
     		double fX = pX + (j * (distanceFX/100));
     		double fY = pY + (j * (distanceFY/100));
     		
     		bezierPoints.add(new Point(fX, fY));
     	}   
    	return bezierPoints;
    }
}

